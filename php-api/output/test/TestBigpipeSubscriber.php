<?php
/**==========================================================================
 * 
 * TestBigpipeSubscriber.php - INF / DS / BIGPIPE
 * 
 * Copyright (c) 2012 Baidu.com, Inc. All Rights Reserved
 * 
 * Created on 2012-12-27 by YANG ZHENYU (yangzhenyu@baidu.com)
 * 
 * --------------------------------------------------------------------------
 * 
 * Description
 * 
 * 
 * --------------------------------------------------------------------------
 * 
 * Change Log
 * 
 * 
 ==========================================================================**/
require_once(dirname(__FILE__).'/TestUtilities.class.php');
require_once(dirname(__FILE__).'/../BigpipeSubscriber.class.php');
require_once(dirname(__FILE__).'/../frame/BigpipeMessagePackage.class.php');
require_once(dirname(__FILE__).'/../frame/bigpipe_configures.inc.php');

class TestBigpipeSubscriber extends PHPUnit_Framework_TestCase
{
    public function setUp()
    {
        $this->pipe_name = 'test';
        $this->token = 'token';
        $this->pipelet_id = 2;
        $this->start_point = -2;
        $this->session_id = BigpipeUtilities::get_uid();
        $this->conf = new BigpipeConf;
        $this->conf->checksum_level = BigpipeChecksumLevel::CHECK_FRAME;
        $this->conf->max_failover_cnt = 2; // ÉèÖÃfailover count 

        // Éú³ÉMetaAgentAdapterµÄmockÊµÀı
        $this->stub_meta = $this
            ->getMockBuilder('MetaAgentAdapter')
            ->disableOriginalConstructor()
            ->getMock();
        // Éú³É StompAdapterµÄmockÊµÀı
        $this->stub_stomp = $this
            ->getMockBuilder('BigpipeStompAdapter')
            ->disableOriginalConstructor()
            ->getMock();
    }

    public function testInit()
    {
        // ²âÊÔ1 multi-init an object
        $subject = new BigpipeSubscriber;
        $this->assertTrue(TestUtilities::set_private_var(
            $subject, '_inited', true));
        $this->assertFalse($subject->init(
            $this->pipe_name,
            $this->token,
            $this->pipelet_id,
            $this->start_point,
            $this->conf));

        // ²âÊÔ2 invalid start point
        $this->assertTrue(TestUtilities::set_private_var(
            $subject, '_inited', false));
        $this->assertFalse($subject->init(
            $this->pipe_name,
            $this->token,
            $this->pipelet_id,
            -50,
            $this->conf));

        // mock meta adapter
        $this->stub_meta->expects($this->any())
            ->method('init')
            ->will($this->onConsecutiveCalls(false, true, true, true, true, true));
        $this->stub_meta->expects($this->any())
            ->method('connect')
            ->will($this->onConsecutiveCalls(false, true, true, true, true));

        $max_pipelet_id = 10;
        $good_author = array(
            'authorized'  => true,
            'num_pipelet' => $max_pipelet_id,
        );

        $bad_author = false;

        $failed_author = array(
            'authorized' => false,
            'reason'     => 'fake author'
        );

        $this->stub_meta->expects($this->any())
            ->method('authorize')
            ->will($this->onConsecutiveCalls($bad_author, $failed_author, $good_author, $good_author));
        $this->assertTrue(TestUtilities::set_private_var($subject, '_meta_adapter', $this->stub_meta));

        // ²âÊÔ3 init_metaÊ§°Ü
        $this->assertFalse($subject->init(
            $this->pipe_name,
            $this->token,
            $this->pipelet_id,
            $this->start_point,
            $this->conf));

        // ²âÊÔ4 checksum level error
        $this->conf->checksum_level = -10;
        $this->assertFalse($subject->init(
            $this->pipe_name,
            $this->token,
            $this->pipelet_id,
            $this->start_point,
            $this->conf));
        $this->conf->checksum_level = BigpipeChecksumLevel::CHECK_FRAME;

        // ²âÊÔ5 meta adapter connect error
        $this->assertFalse($subject->init(
            $this->pipe_name,
            $this->token,
            $this->pipelet_id,
            $this->start_point,
            $this->conf));

        // ²âÊÔ6 ÈÏÖ¤Ê§°Ü
        $this->assertFalse($subject->init(
            $this->pipe_name,
            $this->token,
            $this->pipelet_id,
            $this->start_point,
            $this->conf));

        // ²âÊÔ7 ÈÏÖ¤±»¾Ü
        $this->assertFalse($subject->init(
            $this->pipe_name,
            $this->token,
            $this->pipelet_id,
            $this->start_point,
            $this->conf));

        // ²âÊÔ8 ÈÏÖ¤³É¹¦£¬µ«pipelet id´íÎó
        $this->assertFalse($subject->init(
            $this->pipe_name,
            $this->token,
            $max_pipelet_id,
            $this->start_point,
            $this->conf));

        // ²âÊÔ9 init³É¹¦
        $this->assertTrue($subject->init(
            $this->pipe_name,
            $this->token,
            $this->pipelet_id,
            $this->start_point,
            $this->conf));

        // _inited ¸´Î»
        $this->assertTrue(TestUtilities::set_private_var(
            $subject, '_inited', false));
    }

    public function testPeek()
    {
        $subject = new BigpipeSubscriber;
        $timo_ms = 100;

        // ²âÊÔ1 not inited
        $this->assertEquals(BigpipeErrorCode::UNINITED, $subject->peek($timo_ms));
        $this->assertTrue(TestUtilities::set_private_var(
            $subject, '_inited', true));

        // ÉèÖÃmeta_adapterµÄĞĞÎª
        $this->stub_meta->expects($this->once())
            ->method('get_sub_broker_group')
            ->will($this->onConsecutiveCalls(false));

        $this->assertTrue(TestUtilities::set_private_var(
            $subject, '_meta_adapter', $this->stub_meta));

        // ²âÊÔ2 flush subscribe error
        $this->assertEquals(BigpipeErrorCode::ERROR_SUBSCRIBE, $subject->peek($timo_ms));

        // ²âÊÔ3 ²âÊÔpackageÎª¿Õ
        $pkg = new BigpipeMessagePackage;
        $this->assertTrue(TestUtilities::set_private_var(
            $subject, '_is_subscribed', true));
        $this->assertTrue(TestUtilities::set_private_var(
            $subject, '_package', $pkg));
        $this->stub_stomp->expects($this->once())
            ->method('peek')
            ->will($this->returnValue(BigpipeErrorCode::PEEK_TIMEOUT));
        $this->assertTrue(TestUtilities::set_private_var(
            $subject, '_stomp_adapter', $this->stub_stomp));
        $this->assertEquals(BigpipeErrorCode::PEEK_TIMEOUT, $subject->peek($timo_ms));

        // ²âÊÔ4 package ·Ç¿Õ
        $pkg->push('A testing message');
        $this->assertEquals(BigpipeErrorCode::READABLE, $subject->peek($timo_ms));

        // _inited ¸´Î»
        $this->assertTrue(TestUtilities::set_private_var(
            $subject, '_inited', false));
    }

    public function testReceive()
    {
        $subject = new BigpipeSubscriber;
        $timo_ms = 100;
        $this->assertTrue(TestUtilities::set_private_var(
            $subject, '_pipelet_msg_id', 65535));

        echo "test receive\n";
        // ²âÊÔ1 not inited
        $this->assertFalse($subject->receive());
        $this->assertTrue(TestUtilities::set_private_var(
            $subject, '_inited', true));

        // ²âÊÔ2 Î´¶©ÔÄÊ§°Ü
        $this->assertFalse($subject->receive());
        $this->assertTrue(TestUtilities::set_private_var(
            $subject, '_is_subscribed', true));

        // ²âÊÔ3 ´æÔÚmessage package
        $pkg = new BigpipeMessagePackage;
        $msg = 'A testing message';
        $pkg->push($msg);
        $this->assertTrue(TestUtilities::set_private_var(
            $subject, '_package', $pkg));
        $recv_ret = $subject->receive();
        $this->assertTrue(false !== $recv_ret);
        $this->assertEquals($msg, $recv_ret->content);

        // ²âÊÔ4 ²âÊÔ_receive()
        // ¶¨ÖÆmeta adapterĞĞÎª
        $sub_info = $this->_gen_sub_broker_group();
        $sub_info['end_pos'] = 65535; // ĞŞ¸Äend pos 
        $this->stub_meta->expects($this->any())
            ->method('get_sub_broker_group')
            ->will($this->returnValue($sub_info));

        $this->assertTrue(TestUtilities::set_private_var(
            $subject, '_meta_adapter', $this->stub_meta));

        // ¶¨ÖÆstomp adapterĞĞÎª
        $res_arr = $this->_gen_recv_response();
        $this->stub_stomp->expects($this->any())
            ->method('send')
            ->will($this->returnValue(false));
        $this->stub_stomp->expects($this->any())
            ->method('close')
            ->will($this->returnValue(true));
        $this->stub_stomp->expects($this->any())
            ->method('connect')
            ->will($this->returnValue(true));
        $this->stub_stomp->expects($this->any())
            ->method('receive')
            ->will($this->onConsecutiveCalls(
                null, 
                'failure',
                $res_arr['bad_topic'],
                $res_arr['bad_body'],
                $res_arr['bad_checksum'],
                $res_arr['bad_pkg'],
                $res_arr['empty_pkg'],
                $res_arr['good']
            ));
        $this->assertTrue(TestUtilities::set_private_var(
            $subject, '_stomp_adapter', $this->stub_stomp));

        // ²âÊÔ4.1 ¿Õresponse body
        $this->assertFalse($subject->receive());
        $this->assertTrue(TestUtilities::set_private_var(
            $subject, '_is_subscribed', true));

        // ²âÊÔ4.2 load response body´íÎó
        $this->assertFalse($subject->receive());
        $this->assertTrue(TestUtilities::set_private_var(
            $subject, '_is_subscribed', true));

        // ²âÊÔ4.3 topic message id´íÎó
        $this->assertFalse($subject->receive());
        $this->assertTrue(TestUtilities::set_private_var(
            $subject, '_is_subscribed', true));

        // ²âÊÔ4.4 ¿Õmessage body´íÎó
        $this->assertFalse($subject->receive());
        $this->assertTrue(TestUtilities::set_private_var(
            $subject, '_is_subscribed', true));

        // ²âÊÔ4.5 Ğ£ÑéÂë´íÎó
        $this->assertFalse($subject->receive());
        $this->assertTrue(TestUtilities::set_private_var(
            $subject, '_is_subscribed', true));

        // ²âÊÔ4.6 load package´íÎó
        $this->assertFalse($subject->receive());
        $this->assertTrue(TestUtilities::set_private_var(
            $subject, '_is_subscribed', true));
        
        // ²âÊÔ4.7 ¿Õpackage popÊ±³ö´í
        $this->assertFalse($subject->receive());
        $this->assertTrue(TestUtilities::set_private_var(
            $subject, '_is_subscribed', true));

        // ²âÊÔ4.8 ³É¹¦£¨ÇÒÇĞ»»stripe£©
        $this->assertTrue(false != $subject->receive());
    }

    /**
     * ²âÊÔuninitºÍ_unsubscribe
     */
    public function testUninit()
    {
        $subject = new BigpipeSubscriber;
        // ²âÊÔ1 uninted
        $subject->uninit();

        $this->assertTrue(TestUtilities::set_private_var(
            $subject, '_inited', true));
        $this->assertTrue(TestUtilities::set_private_var(
            $subject, '_is_subscribed', true));
        $sub_info = $this->_gen_sub_broker_group();
        $this->assertTrue(TestUtilities::set_private_var(
            $subject, '_stripe', $sub_info));
        $subject->unittest = true;

        // ÉèÖÃmeta_adapterµÄĞĞÎª
        $this->stub_meta->expects($this->any())
            ->method('close')
            ->will($this->returnValue(true));

        $this->assertTrue(TestUtilities::set_private_var(
            $subject, '_meta_adapter', $this->stub_meta));

        // ÉèÖÃstomp adapterĞĞÎª
        $this->stub_stomp->expects($this->any())
            ->method('send')
            ->will($this->returnValue(true));
        $unsub_arr = $this->_get_unsub_response();
        $this->stub_stomp->expects($this->any())
            ->method('receive')
            ->will($this->onConsecutiveCalls(
                null,
                'wrong-response',
                $unsub_arr['bad'],
                $unsub_arr['good']
            ));
        $this->assertTrue(TestUtilities::set_private_var(
            $subject, '_stomp_adapter', $this->stub_stomp));

        // ²âÊÔ2 È¡Ïû¶©ÔÄÊ§°ÜÇé¿ö
        // ²âÊÔ2.1 Ã»ÓĞresponse body
        $subject->uninit();
        $this->assertTrue(TestUtilities::set_private_var(
            $subject, '_inited', true));
        $this->assertTrue(TestUtilities::set_private_var(
            $subject, '_is_subscribed', true));
        $sub_info = $this->_gen_sub_broker_group();
        $this->assertTrue(TestUtilities::set_private_var(
            $subject, '_stripe', $sub_info));
        $this->assertTrue(TestUtilities::set_private_var(
            $subject, '_stomp_adapter', $this->stub_stomp));

        // ²âÊÔ2.2 load ack Ê§°Ü
        $subject->uninit();
        $this->assertTrue(TestUtilities::set_private_var(
            $subject, '_inited', true));
        $this->assertTrue(TestUtilities::set_private_var(
            $subject, '_is_subscribed', true));
        $sub_info = $this->_gen_sub_broker_group();
        $this->assertTrue(TestUtilities::set_private_var(
            $subject, '_stripe', $sub_info));
        $this->assertTrue(TestUtilities::set_private_var(
            $subject, '_stomp_adapter', $this->stub_stomp));
        
        // ²âÊÔ2.3 receipt_idÊ§°Ü
        $subject->uninit();
        $this->assertTrue(TestUtilities::set_private_var(
            $subject, '_inited', true));
        $this->assertTrue(TestUtilities::set_private_var(
            $subject, '_is_subscribed', true));
        $sub_info = $this->_gen_sub_broker_group();
        $this->assertTrue(TestUtilities::set_private_var(
            $subject, '_stripe', $sub_info));
        $this->assertTrue(TestUtilities::set_private_var(
            $subject, '_stomp_adapter', $this->stub_stomp));

        // ²âÊÔ3 ¶©ÔÄ³É¹¦
        $subject->uninit();
    }

    /**
     * ²âÊÔ_subscribe
     */
    public function testSubscribe()
    {
        $subject = new BigpipeSubscriber;
        $method = TestUtilities::get_private_method($subject, '_subscribe');
        $this->assertTrue(false !== $method);

        // ÅäÖÃsubjectË½ÓĞ±äÁ¿
        $sub_info = $this->_gen_sub_broker_group();
        $this->assertTrue(TestUtilities::set_private_var(
            $subject, '_stripe', $sub_info));
        $this->assertTrue(TestUtilities::set_private_var(
            $subject, '_pipelet_msg_id', -2));
        $subject->unittest = true;

        // ÅäÖÃstompĞĞÎª
        $this->stub_stomp->expects($this->any())
            ->method('send')
            ->will($this->returnValue(true));
        $unsub_arr = $this->_get_unsub_response();
        $this->stub_stomp->expects($this->any())
            ->method('receive')
            ->will($this->onConsecutiveCalls(
                null,
                'wrong-response',
                $unsub_arr['bad'],
                $unsub_arr['good']
            ));
        $this->assertTrue(TestUtilities::set_private_var(
            $subject, '_stomp_adapter', $this->stub_stomp));

        // ²âÊÔ1 res_bodyÎªnull
        $this->assertFalse($method->invoke($subject));

        // ²âÊÔ2 load ackÊ§°Ü
        $this->assertFalse($method->invoke($subject));

        // ²âÊÔ3 receipt id²»¶Ô
        $this->assertFalse($method->invoke($subject));

        // ²âÊÔ4 ³É¹¦
        $this->assertTrue($method->invoke($subject));
    }

    /**
     * ²âÊÔ_update_meta
     */
    public function testUpdateMeta()
    {
        $subject = new BigpipeSubscriber;
        $method = TestUtilities::get_private_method($subject, '_update_meta');
        $this->assertTrue(false !== $method);

        // ÉèÖÃmeta_adapterµÄĞĞÎª
        $sub_info = $this->_gen_sub_broker_group();
        $grp_fail = $this->_gen_sub_broker_group();
        $grp_fail['broker_group']->status = BigpipeBrokerGroupStatus::FAIL;
        $no_cand = $this->_gen_sub_broker_group();
        $no_cand['broker_group']->brokers[1]->role = BigpipeBrokerRole::PRIMARY;
        $this->stub_meta->expects($this->any())
            ->method('get_sub_broker_group')
            ->will($this->onConsecutiveCalls($grp_fail, $no_cand, $sub_info, $sub_info, $sub_info));

        $this->assertTrue(TestUtilities::set_private_var(
            $subject, '_meta_adapter', $this->stub_meta));
        $this->assertTrue(TestUtilities::set_private_var(
            $subject, '_pipelet_msg_id', SubscribeStartPoint::START_FROM_FIRST_POINT));

        // ²âÊÔ1 È¡µ½µÄgroupÊÇfail×´Ì¬
        $this->assertFalse($method->invoke($subject));

        // ²âÊÔ2 ÎŞºòÑ¡Õß
        $this->assertFalse($method->invoke($subject));

        // ²âÊÔ3 preferÌõ¼ş²»¶Ô
        $this->assertTrue(TestUtilities::set_private_var(
            $subject, '_pref_conn', 9));
        $this->assertFalse($method->invoke($subject));

        // ²âÊÔ4 ³É¹¦²¢Ñ¡È¡primary broker
        $this->assertTrue(TestUtilities::set_private_var(
            $subject, '_pref_conn', BigpipeConnectPreferType::PRIMARY_BROKER_ONLY));
        $this->assertTrue($method->invoke($subject));
        $brokers = TestUtilities::get_private_var($subject, '_brokers');
        $this->assertTrue(false != $brokers);
        $this->assertEquals(1, count($brokers));
        $this->assertEquals(BigpipeBrokerRole::PRIMARY, $brokers[0]->role);

        // ²âÊÔ5 ³É¹¦²¢Ñ¡È¡secondary broker
        $this->assertTrue(TestUtilities::set_private_var(
            $subject, '_pref_conn', BigpipeConnectPreferType::SECONDARY_BROKER_ONLY));
        $this->assertTrue($method->invoke($subject));
        $brokers = TestUtilities::get_private_var($subject, '_brokers');
        $this->assertTrue(false != $brokers);
        $this->assertEquals(1, count($brokers));
        $this->assertEquals(BigpipeBrokerRole::SECONDARY, $brokers[0]->role);
    }

    /**
     * ´ÓÎÄ¼şÖĞ¶ÁÈ¡broker groupÌá¹©¸ø²âÊÔÓÃÀı
     * @return sub_info on success or false on failure
     */
    private function _gen_sub_broker_group()
    {
        $pathname = './sub_info.json';
        if (false === file_exists($pathname))
        {
            // missing example file
            return false;
        }

        $content = file_get_contents($pathname);
        $broker_group = json_decode($content);
        if (null === $broker_group)
        {
            return false;
        }

        $sub_info = array(
            'stripe_name' => $broker_group->stripe_name,
            'stripe_id'   => $broker_group->stripe_id,
            'begin_pos'   => $broker_group->begin_pos,
            'end_pos'     => $broker_group->end_pos,
            'broker_group' => $broker_group->broker_group,
        );
        return $sub_info;
    }

    private function _gen_recv_response()
    {
        $topic_id = 65535;
        $bad_topic_id = 0;
        $pkg = new BigpipeMessagePackage;
        $msg = 'This is a test case';
        $pkg->push($msg);
        $msg_body = null;
        $pkg->store($msg_body);
        $sign = creat_sign_mds64($msg_body);

        $frame = new BStompMessageFrame;
        $frame->priority = 10;
        $frame->persistent = 1;
        $frame->no_dedupe  = 1;
        $frame->timeout = BigpipeUtilities::get_time_us();
        $frame->destination = 'cluster-for-unittest';
        $frame->session_id = BigpipeUtilities::get_uid();
        $frame->subscribe_id = BigpipeUtilities::get_uid();
        $frame->receipt_id = BigpipeUtilities::gen_receipt_id();
        $frame->session_message_id = BigpipeUtilities::get_uid();
        $frame->topic_message_id = $topic_id;
        $frame->global_message_id = 76248;
        $frame->cur_checksum = $sign[2]; 
        $frame->last_checksum = 0;
        $frame->message_body = $msg_body;

        $frame->store();
        $good =$frame->buffer();

        // topic message id ´íÎóµÄcase
        $frame->topic_message_id = $bad_topic_id;
        $frame->store();
        $bad_topic = $frame->buffer();

        // message body ´íÎóµÄcase
        $frame->topic_message_id = $topic_id;
        $frame->message_body = '';
        $frame->store();
        $bad_body = $frame->buffer();

        // checksum´íÎóµÄcase
        $frame->message_body = $msg_body;
        $frame->cur_checksum = 201;
        $frame->store();
        $bad_checksum = $frame->buffer();

        // ´´ÔìÒ»¸öerrorµÄ°ü
        $err_pkg = '1';
        $frame->message_body = $err_pkg;
        $err_sign = creat_sign_mds64($err_pkg);
        $frame->cur_checksum = $err_sign[2];
        $frame->store();
        $bad_pkg = $frame->buffer();

        // ´´ÔìÒ»¸öpop errorµÄ°ü
        $frame->message_body = pack("L2", 1, 5); // ÕâÊÇÒ»¸ö³¤¶ÈÎª5£¬µ«ÊÇÃ»ÓĞÊı¾İµÄ»µ°ü
        $empty_sign = creat_sign_mds64($frame->message_body);
        $frame->cur_checksum = $empty_sign[2];
        $frame->store();
        $empty_pkg = $frame->buffer();

        $res_arr = array(
            'good'      => $good,
            'bad_topic' => $bad_topic,
            'bad_body'  => $bad_body,
            'bad_checksum' => $bad_checksum,
            'bad_pkg'   => $bad_pkg,
            'empty_pkg' => $empty_pkg,
        );
        return $res_arr;
    }

    private function _get_unsub_response()
    {
        $ack = new BStompReceiptFrame;
        $ack->receipt_id = 'unittest-receipt-id';
        $ack->store();
        $good = $ack->buffer();

        $ack->receipt_id = 'wrong-receipt-id';
        $ack->store();
        $bad = $ack->buffer();

        $unsub_ack = array(
            'good' => $good,
            'bad'  => $bad,
        );
        return $unsub_ack;
    }
} // end of TestBigpipeSubscriber

/* vim: set ts=4 sw=4 sts=4 tw=100 : */
?>

